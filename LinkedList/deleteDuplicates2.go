//82. Remove Duplicates from Sorted List II

package linkedList

// func deleteDuplicates2(head *ListNode) *ListNode {
// 	store := make([]*ListNode, 300, 300)
// 	for head != nil {
// 		i := head.Val
// 		if store[head.Val] != nil {
// 		check:
// 			if head.Next.Val == head.Val {
// 				head = head.Next
// 				goto check
// 			}
// 			store[i] = nil
// 		}
// 		store[head.Val] = head
// 		head = head.Next
// 	}
// 	//現在head停在最後一個值(nil) 1 -> 5 -> nil
// 	res := &ListNode{Val: 0}
// 	for i := 0; i < len(store); i++ {
// 		if store[i] != nil {
// 			count := 0
// 			if count == 0 {
// 				head = store[i]
// 				res.Next = head
// 			}
// 			head.Next = store[i]
// 		}
// 	}
// 	return res.Next
// }

// fatal error: out of memory allocating heap arena metadata
// runtime stack:
// runtime.throw({0x4f16d1?, 0xffffffffffffffff?})
// panic.go, line 1067
// runtime.(*mheap).sysAlloc(0x5c0600, 0x42ade0?, 0x5d0808, 0x1)
// malloc.go, line 775
// runtime.(*mheap).grow(0x5c0600, 0x10000?)
// mheap.go, line 1489
// runtime.(*mheap).allocSpan(0x5c0600, 0x10000, 0x0, 0x1)
// mheap.go, line 1244
// runtime.(*mheap).alloc.func1()
// mheap.go, line 962
// runtime.systemstack(0x5f5f000)
// 	/usr/local/go/src/runtime/asm_amd64.s:514 +0x4a fp=0x7f3f9209ee50 sp=0x7f3f9209ee40 pc=0x46d58a
// runtime.systemstack_switch()
// 	/usr/local/go/src/runtime/asm_amd64.s:479 +0x8 fp=0xc00005d820 sp=0xc00005d810 pc=0x46d528
// runtime.(*mheap).alloc(0x20000000?, 0x10000?, 0xc0?)
// mheap.go, line 956
// runtime.(*mcache).allocLarge(0x7f3ff4aa4108?, 0x20000000, 0x1)
// mcache.go, line 234
// runtime.mallocgc(0x20000000, 0x0, 0x0)
// malloc.go, line 1177
// runtime.growslice(0x0, 0x0?, 0x0?, 0x0?, 0x0?)
// slice.go, line 264
// bytes.growSlice({0xc010172000, 0x10000000, 0x352c352c352c352c?}, 0x352c352c352c352c?)
// buffer.go, line 249
// bytes.(*Buffer).grow(0xc00005db08, 0x1)
// buffer.go, line 151
// bytes.(*Buffer).WriteByte(0xc00005db08, 0x2c)
// buffer.go, line 289
// bytes.(*Buffer).WriteRune(0xc00005db08?, 0x4efd93?)
// buffer.go, line 302
// leetcode/precompiled.ListNode.Serialize({0x5, 0xc000016120}, 0x0?)
// listnode.go, line 22
// leetcode/precompiled.(*ListNode).Serialize(0x5a9720?, 0x20?)
// 	<autogenerated>:1 +0x30 fp=0xc00005db70 sp=0xc00005db48 pc=0x4c3350
// leetcode/precompiled.(*Serializer).Serialize(0xc00005ddd0, {0x4d2420, 0xc000016120})
// serializer.go, line 105
// main.main()
// solution.go, line 79
// runtime.main()
// proc.go, line 272
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc00005dfe8 sp=0xc00005dfe0 pc=0x46f541
// runtime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.goparkunlock(...)
// proc.go, line 430
// runtime.forcegchelper()
// proc.go, line 337
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000046fe8 sp=0xc000046fe0 pc=0x46f541
// created by runtime.init.7 in goroutine 1
// proc.go, line 325
// runtime.gopark(0x1?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.goparkunlock(...)
// proc.go, line 430
// runtime.bgsweep(0xc000074000)
// mgcsweep.go, line 317
// runtime.gcenable.gowrap1()
// mgc.go, line 203
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000477e8 sp=0xc0000477e0 pc=0x46f541
// created by runtime.gcenable in goroutine 1
// mgc.go, line 203
// runtime.gopark(0x10000?, 0x5140b8?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.goparkunlock(...)
// proc.go, line 430
// runtime.(*scavengerState).park(0x5b7880)
// mgcscavenge.go, line 425
// runtime.bgscavenge(0xc000074000)
// mgcscavenge.go, line 658
// runtime.gcenable.gowrap2()
// mgc.go, line 204
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000047fe8 sp=0xc000047fe0 pc=0x46f541
// created by runtime.gcenable in goroutine 1
// mgc.go, line 204
// runtime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.runfinq()
// mfinal.go, line 193
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000487e8 sp=0xc0000487e0 pc=0x46f541
// created by runtime.createfing in goroutine 1
// mfinal.go, line 163
// runtime.gopark(0x5b8620?, 0xc0000467d0?, 0x85?, 0x78?, 0x5ae6b0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000467e8 sp=0xc0000467e0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
// runtime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000048fe8 sp=0xc000048fe0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
// runtime.gopark(0x0?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000497e8 sp=0xc0000497e0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
// runtime.gopark(0x1d9125ef56adf?, 0x1?, 0xbe?, 0x68?, 0x0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000049fe8 sp=0xc000049fe0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
// runtime.gopark(0x5d7dc0?, 0x1?, 0x93?, 0xa8?, 0x0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000427e8 sp=0xc0000427e0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
// runtime.gopark(0x1d9125ef56161?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000042fe8 sp=0xc000042fe0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
// runtime.gopark(0x1d9125ef56d05?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc0000437e8 sp=0xc0000437e0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
// runtime.gopark(0x1d9125ef56585?, 0x0?, 0x0?, 0x0?, 0x0?)
// proc.go, line 424
// runtime.gcBgMarkWorker(0xc000102070)
// mgc.go, line 1363
// runtime.gcBgMarkStartWorkers.gowrap1()
// mgc.go, line 1279
// runtime.goexit({})
// 	/usr/local/go/src/runtime/asm_amd64.s:1700 +0x1 fp=0xc000043fe8 sp=0xc000043fe0 pc=0x46f541
// created by runtime.gcBgMarkStartWorkers in goroutine 1
// mgc.go, line 1279
/*
func deleteDuplicates(head *ListNode) *ListNode {
	store := make([]int, 201, 201)
	curr := head
	clone := &ListNode{Val: 0}
	clone.Next = curr
	for clone != nil {
		if clone.Val < 0 { //負數從101開始記錄
			clone.Val = -clone.Val + 100 //clone.Val的變化不重要，後面會再初始化clone
		}
		store[clone.Val]++
		clone = clone.Next
	}
	//clone指在nil
	clone = &ListNode{Val: 0}
	res := &ListNode{Val: 0}
	for head != nil {
		if head.Val < 0 {
			i := head.Val
			if store[-i+100] == 1 {
				clone.Next = head
				clone = clone.Next
				if res.Next == nil {
					res.Next = clone
				}
			}
			if store[-i+100] > 1 {
				clone.Next = head.Next
			}
		}
		if head.Val >= 0 {
			if store[head.Val] == 1 {
				clone.Next = head
				clone = clone.Next
				if res.Next == nil {
					res.Next = clone
				}
			}
			if store[head.Val] > 1 {
				clone.Next = head.Next
			}
			head = head.Next
		}
	}
	return res.Next
}

//[-1,0,0,0,0,3,3]
//Output
//[101]
//為什麼會污染？？
因為指在同一個記憶體位址

*/
//不要動原始資料

func deleteDuplicates(head *ListNode) *ListNode {
	count := make(map[int]int)
	stay := &ListNode{Val: 0}
	stay.Next = head
	stay = stay.Next
	for stay != nil {
		count[stay.Val]++
		stay = stay.Next
	}
	res := &ListNode{Val: 0}
	res_cur := res
	for head != nil {
		if count[head.Val] == 1 {
			res_cur.Next = head
			res_cur = res_cur.Next
		}
		head = head.Next
	}
	res_cur.Next = nil
	return res.Next
}

//Runtime 2ms Beats 7.14%
//Memory 5.50MB Beats 6.12%
